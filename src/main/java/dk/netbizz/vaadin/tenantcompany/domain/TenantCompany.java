package dk.netbizz.vaadin.tenantcompany.domain;

import dk.netbizz.vaadin.gridpro.utils.gridprogenerator.BaseEntity;
import dk.netbizz.vaadin.gridpro.utils.gridprogenerator.GridEditColumn;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.annotation.Version;
import org.springframework.data.relational.core.mapping.Column;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

/**
 * This is the root aggregate in terms of DDD.
 * The hierarchy goes as this:
 *      TenantCompany -> TenantDepartment -> Employee -> Item
 *
 * Since Spring Data JDBC is mapped to the DDD patterns it will normally read and write the entire
 * aggregate hierarchy for every update, which is a huge performance hit. Even worse, it deletes all embedded/related
 * items before reinserting them to do an update. That is a huge waste!
 * Also, in case of very big object graphs, both in width and height, selecting a list of the root aggregates can
 * take a very annoying and counter productive amount of time.
 *
 * Nevertheless, having automatic mapping between a SQL table and your POJO is valuable and the ListCrudRepository<>
 * interface is a productivity boost as such. Unfortunately it will by default fetch all embedded/related items
 * and item lists unless they are marked with @Transient.
 *
 * So to be able to control the amount of data being handled per transaction all embedded/related entities and lists are
 * marked with @Transient, but then we need another way to fetch them.
 * The strategy is simple:
 *      Create a standard Spring Data JDBC ListCrudRepository<Object, key> for each entity and mark the relevant
 *      properties of the entity with @Transient
 *      If not the root aggregate, then create a method to fetch the set of entities belonging to the parent entity
 *      using the @Query annotation.
 *
 *      Create a @Transactional @Service for each entity with the proper functionality to fetch the embedded/related
 *      entities of the next level using the @Repository of the embedded entity.
 *
 *      We ONLY EVER SAVE individual entities to avoid a massive overhead, so saving the TenantCompany entity will never
 *      automagically save the set of related TenantDepartments, but we will provide a transactional method that
 *      will do so.
 *
 * Using TenantCompany and TenantDepartment as an example:
 * A TenantCompany has multiple departments, but a department belongs to only one company,
 * hence the SQL DDL looks like this:
 *
 * create table if not exists netbizz.tenant_company (
 *     id integer not null generated by default as identity primary key,
 *     version integer,
 *     company_name character varying (50) not null,
 *     address_street character varying (50) not null,
 *     address_zip_city character varying (50) not null
 * );
 * alter sequence tenant_company_id_seq restart with 1000;
 * create unique index on netbizz.tenant_company(lower(trim(company_name)));
 *
 * create table if not exists netbizz.tenant_department (
 *     id integer not null generated by default as identity primary key,
 *     version integer,
 *     tenant_company_id integer not null,
 *     department_name character varying (50) not null,
 *     description character varying (250),
 *     foreign key(tenant_company_id) references tenant_company(id) on delete cascade
 * );
 * alter sequence tenant_department_id_seq restart with 1000;
 * create index on netbizz.tenant_department(tenant_company_id);
 * create unique index on netbizz.tenant_department(tenant_company_id, lower(trim(department_name)));
 *
 * Then we create matching POJO classes (here before additional annotations), but with a Liat of employees
 * embedded in TenantDepartment to illustrate the use of @Transient in the continued hierarchy:
 *
 * public class TenantCompany implements BaseEntity, Serializable {
 *     @Id
 *     private Integer id;
 *     @Version
 *     private Integer version = null;
 *
 *     private String companyName;
 *     private String addressStreet;
 *     private String addressZipCity;
 *     private List<TenantDepartment> departments = new ArrayList<>();*
 * }
 *
 * public class TenantDepartment implements BaseEntity, Serializable {
 *     @Id
 *     private Integer id;
 *     @Version
 *     private Integer version = null;
 *
 *     private Integer tenantCompanyId;                    // Foreign Key to TenantCompany
 *     private String departmentName;
 *     private String description;
 *
 *     @Transient
 *     private List<ApplicationUser> employees = new ArrayList<>();
 * }
 *
 * Then we create the following two repositories
 *
 * // Transactional is default for all methods
 * @Repository
 * public interface TenantCompanyRepository extends ListCrudRepository<TenantCompany, Integer> {
 *
 *     @Query("select * from tenant_company where company_name = :lowerCaseName")
 *     Optional<TenantCompany> findByCompanyNameIgnoreCase(String lowerCaseName);
 * }
 *
 * @Repository
 * public interface TenantDepartmentRepository extends ListCrudRepository<TenantDepartment, Integer> {
 *
 *     @Query("select * from tenant_department where tenant_company_id = :tenantCompanyId")
 *     List<TenantDepartment> findByTenantCompanyId(int tenantCompanyId);
 * }
 *
 * and the following two services as a minimum:
 *
 * @Service
 * public class TenantCompanyService {
 *
 *     @Transactional
 *     public TenantCompany findById(Integer id) {
 *         Optional<TenantCompany> optionalTenantCompany = ServicePoint.getInstance().getTenantCompanyRepository().findById(id);
 *         if (optionalTenantCompany.isPresent()) {
 *             TenantCompany tenantCompany = optionalTenantCompany.get();
 *             tenantCompany.setDepartments(ServicePoint.getInstance().getTenantDepartmentService().findByTenantCompanyId(tenantCompany.getId()));
 *             return tenantCompany;
 *         }
 *         return null;
 *     }
 *
 *     @Transactional
 *     public List<TenantCompany> findAll() {
 *         List<TenantCompany> tenantCompanyList = ServicePoint.getInstance().getTenantCompanyRepository().findAll();
 *         for (TenantCompany tenantCompany : tenantCompanyList) {
 *             tenantCompany.setDepartments(ServicePoint.getInstance().getTenantDepartmentService().findByTenantCompanyId(tenantCompany.getId()));
 *         }
 *         return tenantCompanyList;
 *     }
 * }
 *
 *
 *
 *
 */


@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TenantCompany implements BaseEntity, Serializable {

    @GridEditColumn(header = "Id", dbColumnName = "id", order = 0)
    @EqualsAndHashCode.Include
    @Id
    private Integer id;
    @Version
    private Integer version = null;

    @GridEditColumn(header = "Company name", dbColumnName = "company_name", order = 1, fieldLength = 50)
    private String companyName;

    @GridEditColumn(header = "Street address", dbColumnName = "address_street", order = 2, fieldLength = 50)
    private String addressStreet;

    @GridEditColumn(header = "Zip code and City", dbColumnName = "address_zip_city", order = 3, fieldLength = 50)
    private String addressZipCity;

   @Transient
    private List<TenantDepartment> departments = new ArrayList<>();

    @Override
    public String toString() {
        return "TenantCompany{" +
                "id=" + id +
                ", companyName='" + companyName + '\'' +
                ", addressStreet='" + addressStreet + '\'' +
                ", addressZipCity='" + addressZipCity + '\'' +
                '}';
    }

}
